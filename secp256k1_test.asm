	ORG	0x8000
START:	JP	TMODMUL
	JP	TMODINV
; Tests 256 bit modular multiplication
; In: XVALUE, YVALUE: little-endian 256 bit multiplicands, EXPECT: little-endian 256 bit expected product
; Out: B = 0 if test passed, length of erroneous prefix (LSB) otherwise
TMODMUL:LD	HL,PRODUCT
	EXX
	PUSH	HL
	LD	HL,XVALUE
	LD	DE,YVALUE
	CALL	MODMUL
	EXX
	POP	HL
	EXX
	LD	DE,EXPECT + 0x20
	LD	BC,0x2000
CHECK:	DEC	DE
	DEC	HL
	LD	A,(DE)
	CP	(HL)
	RET	NZ
	DJNZ	CHECK
	RET
; Tests 256 bit modular inverse
; In: XVALUE: value to invert
; Out: BC = 0 if test passed
TMODINV:LD	HL,XVALUE
	LD	DE,XINV
	CALL	MODINV
	LD	HL,PRODUCT
	EXX
	PUSH	HL
	LD	HL,XVALUE
	LD	DE,XINV
	CALL	MODMUL
	EXX
	POP	HL
	EXX
	LD	BC,0x1F00
CHECKI:	DEC	HL
	LD	A,(HL)
	CP	C
	RET	NZ
	DJNZ	CHECKI
	INC	C
	DEC	HL
	DEC	(HL)
	RET	NZ
	DEC	C
	RET

	INCLUDE	"secp256k1.asm"
	INCLUDE "bigmul.asm"
	INCLUDE "mul8bit.asm"
XVALUE:	DEFB	0x77, 0x41, 0x27, 0xA4
	DEFB	0x8B, 0xF2, 0x36, 0xE4
	DEFB	0x1E, 0x82, 0x2C, 0xB3
	DEFB	0x56, 0x69, 0x9B, 0xDA
	DEFB	0x5A, 0x12, 0x65, 0xA7
	DEFB	0xB7, 0x1B, 0x48, 0x3F
	DEFB	0xB7, 0x44, 0x60, 0x33
	DEFB	0xF1, 0x4F, 0x24, 0xDA
YVALUE:	DEFB	0x44, 0xEE, 0xF5, 0xA6
	DEFB	0xD9, 0xBF, 0x44, 0xEC
	DEFB	0xF6, 0xBA, 0x79, 0x4E
	DEFB	0x0D, 0xB4, 0xB9, 0xB3
	DEFB	0xF5, 0xF7, 0x46, 0x57
	DEFB	0x58, 0x5F, 0x64, 0x02
	DEFB	0x33, 0xFF, 0x1F, 0x53
	DEFB	0x73, 0xE5, 0x94, 0x7E
EXPECT:	DEFB	0xE2, 0x46, 0x97, 0x98
	DEFB	0x74, 0x5F, 0x1C, 0x8A
	DEFB	0xC8, 0x2A, 0xEA, 0x80
	DEFB	0x3F, 0xC8, 0x0F, 0xCB
	DEFB	0xC0, 0xAE, 0x81, 0xAA
	DEFB	0x7E, 0x95, 0xED, 0xFC
	DEFB	0x59, 0x1C, 0x97, 0x12
	DEFB	0x2B, 0xFF, 0xB6, 0xD7
XINV:	EQU	0x5800
MODINVU:EQU	XINV + 0x20
MODINVV:EQU	MODINVU	+ 0x22
MODINVD:EQU	MODINVV + 0x22
MODINVA:EQU	MODINVD + 0x20
MODINVUV:EQU	MODINVA + 2
PRODUCT:EQU	XVALUE + 0x100
